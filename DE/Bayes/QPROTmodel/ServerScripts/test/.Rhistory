library(mclust)
#library(factoextra)
library(MASS)
library(ggplot2)
setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/LocalScripts/test')
outFile <- "PXD004682_QPROTmodel_testResult.csv"
subsets <- list.files(pattern = "out_*", full.names = FALSE)
results <- NULL
for (subset in subsets) {
data <- tryCatch(read.csv(file = subset), error = function(e) NULL)
results <- rbind(results, data)
}
zeds <- results[,c(2,17)]
dens <- densityMclust(zeds$Zstatistic)
plot(dens, what = 'density' )
mc <- Mclust(zeds$Zstatistic, G = 2)
plot(mc, what = 'classification')
summary(mc)
#fviz_mclust(mc, 'classification')
mc$parameters
fviz_mclust(mc, 'classification')
library(factoextra)
View(mc)
View(zeds)
qprot_result <- read.table('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTout_test', sep = '/')
View(qprot_result)
qprot_result <- read.table('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTout_test', sep = '/t')
qprot_result <- read.table('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTout_test', sep = '\t')
View(qprot_result)
qprot_result <- read.table('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTout_test', header = TRUE, sep = '\t')
View(qprot_result)
qprot_zeds <- qprot_result[,c(1, 16)]
qprot_dens <- denstityMclust(qprot_zeds$Zstatistic)
qprot_dens <- densityMclust(qprot_zeds$Zstatistic)
plot(qprot_dens, what = 'density' )
setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts')
args <- c('PXD004682_QPROTin_testShort', 'PXD004682', '5')
dataSet <- args[2]
model_input <- read.table(args[1], sep = '\t', header = TRUE)
model_input <- read.table(args[1], sep = '\t', header = TRUE)
View(model_input)
model_input<- model_input[, 1:14]
View(model_input)
proteins <- nrow(model_input)
split <- as.numeric(args[3])
subs <- ceiling(proteins/split)
#Replaces zero values
model_input[model_input == 0] <- 0.00001
#Logs the intensities
model_input[,2:7] <- log(model_input[2:7])
View(model_input)
#setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/test')
for (i in 1:split) {
firstLine <- (subs * (i-1)) + 1
#print(firstLine)
lastLine <- subs * i
#print(lastLine)
dataSub <- model_input[firstLine:lastLine,]
loop <- i
outFile <- paste('subset', loop, '.csv', sep = '')
write.csv(dataSub, outFile)
}
model_input <- read.table(args[1], sep = '\t', header = TRUE)
View(model_input)
model_input<- model_input[, 1:14]
proteins <- nrow(model_input)
split <- as.numeric(args[3])
subs <- ceiling(proteins/split)
#Replaces zero values
model_input[model_input == 0] <- 0.00001
#Logs the intensities
model_input[,2:7] <- log(model_input[2:7])
setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/test')
#setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/test')
for (i in 1:split) {
firstLine <- (subs * (i-1)) + 1
#print(firstLine)
lastLine <- subs * i
#print(lastLine)
dataSub <- model_input[firstLine:lastLine,]
loop <- i
outFile <- paste('subset', loop, '.csv', sep = '')
write.csv(dataSub, outFile)
}
View(model_input)
model_input <- read.table(args[1], sep = '\t', header = TRUE)
setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts')
model_input <- read.table(args[1], sep = '\t', header = TRUE)
model_input<- model_input[, 1:14]
proteins <- nrow(model_input)
split <- as.numeric(args[3])
subs <- ceiling(proteins/split)
#Replaces zero values
model_input[model_input == 0] <- 0.00001
#Logs the intensities
model_input[,2:7] <- log(model_input[2:7])
setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/test')
#setwd('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/test')
for (i in 1:split) {
firstLine <- (subs * (i-1)) + 1
#print(firstLine)
lastLine <- subs * i
#print(lastLine)
dataSub <- model_input[firstLine:lastLine,]
loop <- i
outFile <- paste('subset', loop, '.csv', sep = '')
write.csv(dataSub, outFile)
}
library(Rcpp)
library(rstan)
ch = 4
c = 1
loc_input = 650
qprot_iterations = loc_input*c
wu = loc_input/2
AD = 0.9
fileName <- args[1]
#fileName <- 'subset1'
#fileIn <- paste(fileName, '.csv', sep = '')
outFile <- paste('out_', fileName, sep = '')
QPROTmodel_input <- read.table(fileName, sep = ',', header = TRUE)
args <- c('subset1.csv', 'PXD004682')
fileName <- args[1]
#fileName <- 'subset1'
#fileIn <- paste(fileName, '.csv', sep = '')
outFile <- paste('out_', fileName, sep = '')
QPROTmodel_input <- read.table(fileName, sep = ',', header = TRUE)
#print(paste('Processing file: ', fileName, sep = ''))
#head(QPROTmodel_input)
QPROTmodel_input <- QPROTmodel_input[, 2:15]
indicator <- c(0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)             #Describes experimental set up
numProteins <- nrow(QPROTmodel_input)               #Number of proteins in dat-set
numRuns <- length(indicator)                   #Total number of runs
QPROTmodel_output <- QPROTmodel_input
QPROTmodel_output$LogFC <- 1
QPROTmodel_output$Zstatistic <- 1
# # #Performs stan model on each protein in data-set
for (protein in 1:numProteins) {
intensities <- NULL
d <- NULL
p <- QPROTmodel_input[protein, 1]
intensities <- as.numeric(QPROTmodel_input[protein, c(2:14)])
#Input data for Stan model
protData <- list(
T = indicator,                             #Identifies condition intesity belongs to (0 or 1)
N = numRuns,                               #Number of intensities per protein
y = intensities                                 #Protein intensity values, logged
)
#Runs stan model from file
fit <- stan(
#Path to stan model script
file = '/mnt/hc-storage/users/hprice/Rbatch/QPROTmodel/QPROTmodel.stan',
data = protData,
chains = ch,                               #Number of MCMC chains to perform
warmup = wu,                               #Number of iterations for burnin
iter = loc_input,                          #Number of iterations on each chain
cores = c,
control = list(adapt_delta = AD,
max_treedepth = 15)
)
#Extracts summary data for DE
d <- summary(fit, pars = c('d'))
#print(d)
#Extracts the mean and standard DE
mean <- d$summary[1]
sd <- d$summary[3]
#Calcuates the log fold change and the Zstatistic for DE
QPROTmodel_output$LogFC[protein] <- d$summary[1]
QPROTmodel_output$Zstatistic[protein] <- d$summary[1]/d$summary[3]
}
#Runs stan model from file
fit <- stan(
#Path to stan model script
#file = '/mnt/hc-storage/users/hprice/Rbatch/QPROTmodel/QPROTmodel.stan',
file('E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/QPROTmodel.stan'),
data = protData,
chains = ch,                               #Number of MCMC chains to perform
warmup = wu,                               #Number of iterations for burnin
iter = loc_input,                          #Number of iterations on each chain
cores = c,
control = list(adapt_delta = AD,
max_treedepth = 15)
)
#Runs stan model from file
fit <- stan(
#Path to stan model script
#file = '/mnt/hc-storage/users/hprice/Rbatch/QPROTmodel/QPROTmodel.stan',
file = 'E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/QPROTmodel.stan',
data = protData,
chains = ch,                               #Number of MCMC chains to perform
warmup = wu,                               #Number of iterations for burnin
iter = loc_input,                          #Number of iterations on each chain
cores = c,
control = list(adapt_delta = AD,
max_treedepth = 15)
)
#Extracts summary data for DE
d <- summary(fit, pars = c('d'))
View(d)
#Extracts the mean and standard DE
mean <- d$summary[1]
sd <- d$summary[3]
# # #Performs stan model on each protein in data-set
for (protein in 1:numProteins) {
intensities <- NULL
d <- NULL
p <- QPROTmodel_input[protein, 1]
intensities <- as.numeric(QPROTmodel_input[protein, c(2:14)])
#Input data for Stan model
protData <- list(
T = indicator,                             #Identifies condition intesity belongs to (0 or 1)
N = numRuns,                               #Number of intensities per protein
y = intensities                                 #Protein intensity values, logged
)
#Runs stan model from file
fit <- stan(
#Path to stan model script
#file = '/mnt/hc-storage/users/hprice/Rbatch/QPROTmodel/QPROTmodel.stan',
file = 'E:/OneDrive/PhD/Project/Thesis/4_Pipeline/Pipeline/DE/Bayes/QPROTmodel/ServerScripts/QPROTmodel.stan',
data = protData,
chains = ch,                               #Number of MCMC chains to perform
warmup = wu,                               #Number of iterations for burnin
iter = loc_input,                          #Number of iterations on each chain
cores = c,
control = list(adapt_delta = AD,
max_treedepth = 15)
)
#Extracts summary data for DE
d <- summary(fit, pars = c('d'))
#print(d)
#Extracts the mean and standard DE
mean <- d$summary[1]
sd <- d$summary[3]
#Calcuates the log fold change and the Zstatistic for DE
QPROTmodel_output$LogFC[protein] <- d$summary[1]
QPROTmodel_output$Zstatistic[protein] <- d$summary[1]/d$summary[3]
}
write.csv(QPROTmodel_output, outFile)
